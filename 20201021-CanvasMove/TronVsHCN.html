<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tròn vs Hình chữ nhật</title>
    <style>
        canvas {
            /* cursor: none; */
        }
    </style>
</head>

<body>
    <div id="khungdiv"><canvas id="canvas"></canvas></div>
    <script>
        const khung = document.getElementById('canvas')
        const khungto = document.getElementById('khungdiv')
        khung.width = innerWidth * 0.8
        khung.height = innerHeight * 0.8
        khung.style.border = '1px solid black'
        const but = khung.getContext('2d')

        class hinhchunhat {
            constructor(x, y, w, h, c) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h
                this.c = c;
            }

            ve() {
                but.beginPath()
                but.rect(this.x, this.y, this.w, this.h)
                but.fillStyle = this.c
                but.fill()
            }

            move(dx) {
                this.x = dx;
            }
        }

        class hinhtron {
            constructor(x, y, r, c) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.c = c;
                this.trucX = 0
                this.trucY = 0
            }

            ve() {
                but.beginPath()
                but.arc(this.x, this.y, this.r, 0, Math.PI * 2, true)
                but.fillStyle = this.c
                but.fill()
            }

            // Hàm để vẽ liên tục mỗi khi update thêm this.trucX và trucY => tạo hiệu ứng move
            // hàm sẽ được sử dụng trong request frame
            move() {
                this.x = this.x + this.trucX
                this.y = this.y + this.trucY
                if (this.x <= this.r || this.x >= khung.width - this.r) {
                    if (this.x <= this.r) this.x = this.r
                    else this.x = khung.width - this.r
                    this.trucX = -this.trucX
                }
                if (this.y <= this.r || this.y >= khung.height - this.r) {
                    if (this.y <= this.r) this.y = this.r
                    else this.y = khung.height - this.r
                    this.trucY = -this.trucY
                }
                this.ve()
            }

            touchhcn(hcn) {
                let x
                let y
                if (this.x < hcn.x) x = hcn.x
                if (this.x > hcn.x + hcn.w) x = hcn.x + hcn.w
                if (this.x >= hcn.x && this.x <= hcn.x + hcn.w) x = this.x
                if (this.y < hcn.y) y = hcn.y
                if (this.y > hcn.y + hcn.h) y = hcn.y + hcn.h
                if (this.y >= hcn.y && this.y <= hcn.y + hcn.h) y = this.y
                if ((this.x - x) ** 2 + (this.y - y) ** 2 < this.r ** 2) {
                    if (this.x >= hcn.x && this.x <= hcn.x + hcn.w) {
                        this.trucY = -this.trucY
                        return
                    }
                    if (this.y >= hcn.y && this.y <= hcn.y + hcn.h) {
                        this.trucX = -this.trucX
                        return
                    }
                    if (this.x - hcn.x < 0 && this.y - hcn.y < 0) {
                        this.trucX = -Math.abs(this.trucX)
                        this.trucY = -Math.abs(this.trucY)
                        return
                    }
                    if (this.x > hcn.x + hcn.w && this.y - hcn.y < 0) {
                        this.trucX = Math.abs(this.trucX)
                        this.trucY = -Math.abs(this.trucY)
                        return
                    }
                    if (this.x < hcn.x && this.y > hcn.y + hcn.h) {
                        this.trucX = -Math.abs(this.trucX)
                        this.trucY = Math.abs(this.trucY)
                        return
                    }
                    if (this.x > hcn.x + hcn.w && this.y > hcn.y + hcn.h) {
                        this.trucX = Math.abs(this.trucX)
                        this.trucY = Math.abs(this.trucY)
                    }
                }
            }
        }

        let htr1 = new hinhtron(30, 30, 30, 'blue')
        htr1.ve()

        let hcn1 = new hinhchunhat(khung.width / 2 - 100, khung.height - 20, 200, 20, 'red')
        hcn1.ve()

        document.addEventListener('keydown', press)
        function press(e) {
            if (e.keyCode == 38) {
                htr1.trucY += -1
            }
            if (e.keyCode == 40) {
                htr1.trucY += 1
            }
            if (e.keyCode == 39) {
                htr1.trucX += 1
            }
            if (e.keyCode == 37) {
                htr1.trucX += -1
            }

            if (e.keyCode == 32) {
                htr1.trucX = 0
                htr1.trucY = 0
            }
        }

        khungto.addEventListener('mousemove', function (e) {
            but.clearRect(0, 0, khung.width, khung.height)
            // let x = e.offsetX - 50
            // let y = e.offsetY - 50
            // if (x<0) x = 0
            // if (y< 0) y = 0
            // if (x+100>khung.width) x = khung.width - 100
            // if (y+100>khung.height) y = khung.height - 100
            // let hcn1 = new hinhchunhat(x, y, 100, 100, 'red')
            // hcn1.ve()
            hcn1.move(e.offsetX-100);
        })

        but.clearRect(0, 0, khung.width, khung.height)

        // Khi chạy hàm này, do có clearRect nên những thứ vẽ bên ngoài clear hết
        // Nên vẽ all trong này
        function chay() {
            requestAnimationFrame(chay);
            but.clearRect(0, 0, khung.width, khung.height)            
            htr1.touchhcn(hcn1)
            htr1.move()
            hcn1.ve()
        }

        chay()
    </script>
</body>

</html>